package driver;

import java.net.*;
import java.io.*;
import java.util.*;

/**
 * @author 2636161
 */

/**
 * This class contains the operations that the node will carry out when making a connection this class will send requests
 * for a token when it has the token it will be able to carry out its critical section then return the token back to the coordinator
 */
public class Node {

	private Random ra;
	private Socket s;
	private PrintWriter pout = null;
	private ServerSocket n_ss;
	
	// Socket that is used to send and return the token
	private Socket n_token;

	// TO IMPLEMENT ADVANCED FEATURE 4: For the node to be able to connect to a different computer instead of using the local host for the c_host
	// I need to use the ip address of the computer that I want to make the connection to and store the ip that the computer uses
	// and store that in the c_host variable
	// Example: String c_host = "139.153.254.121";
	
	//Global Variables that contain the ip and port numbers that the coordinator uses
	String c_host = "127.0.0.1";
	int c_request_port = 7000;
	int c_return_port = 7001;

	// TO IMPLEMENT ADVANCED FEATURE 4: for the node to be able to connect to a different computer instead of using the local host for the n_host
	// I need to use the ip of address that the computer I am are making the connection to and store that in the n_host variable 
	// Example: String n_host = "139.153.254.121";
	
	
	//Global variables that contain information about the node
    String n_host = "127.0.0.1";
	String n_host_name;
	int n_port;
	int sleepTimer;

	/**
	 * This method is the launch point for the nodes to launch a node they must be assigned a unique port number that is not currently in use
	 * and a response time (in miliseconds) 
	 * 
	 * @param args launch parameters for the nodes that are used in the system
	 * 
	 * TO LAUNCH THIS CLASS YOU WILL NEED TO DEFINE THE CLASSES LAUNCH PARAMTERS YOU WILL NEED TO ASSIGN A PORT NUMBER THAT IS NOT BEING USED AND THE RESPONCE TIME FOR THE NODE
	 */
	public static void main(String args[]) {

		// Local variables that hold the host name and port number for the node
		String n_host_name = "";
		int n_port;

		// Port and millisec (average waiting time) are specific of a node
		if ((args.length < 1) || (args.length > 2)) {
			System.out.print("Usage: Node [port number] [millisecs]");
			System.exit(1);
		}
		
		// Get the IP address and the port number of the node
		try {
			InetAddress n_inet_address = InetAddress.getLocalHost();

			// Retrieves the name of the host and stores it in the n_host_name variable
			n_host_name = n_inet_address.getHostName();
			// Prints a message to screen which shows the host name of the node and ip address of the node
			System.out.println("node hostname is " + n_host_name + ":" + n_inet_address);

		 //Error that is displayed if the ip address of the host could not be found
		} catch (java.net.UnknownHostException e) {
			System.out.println("Ip address of the host could not be found");
			System.out.println(e);
			System.exit(1);
		}
		
		// Retrieves the port number that was assigned to the node at run time and stores it in the n_port variable
		n_port = Integer.parseInt(args[0]);

		System.out.println("node port is " + n_port);

		// Creates a new instance of the node class which holds the name of the node the port number and the wait time of the node
		Node n = new Node(n_host_name, Integer.parseInt(args[0]), Integer.parseInt(args[1]));
	}

	/**
	 * Constructor for the node node object that will allow the system to make instances of the node
	 * 
	 * @param nam holds the host name of the node
	 *            
	 * @param por the port number that the node listens on
	 *            
	 * @param sec the average time that it takes for the node to respond        
	 */
	public Node(String nam, int por, int sec) {

		// Create an instance of the random class
		ra = new Random();
		
		// Assigns the node parameters to local variables
		n_host_name = nam;
		n_port = por;
		sleepTimer = sec;

		// Message which shows the name and port number of the node that is active
		System.out.println("Node " + n_host_name + ":" + n_port + " of DME is active ....");

		// NODE sends n_host and n_port through a socket s to the coordinator
		// c_host:c_req_port
		// and immediately opens a server socket through which will receive
		// a TOKEN (actually just a synchronization).

		while (true) {

			// >>> sleep a random number of seconds linked to the initialisation sec value

			// Generates a random int value with the value of the wait time assigned to the node and also an additional 3 second wait time

			int ranSleep = ra.nextInt(sleepTimer) + 3000;

			try {
				// Causes a delay until the next request can be made this the delay is equal to the value that was generated by ranSleep
				Thread.sleep(ranSleep);
			} catch (InterruptedException e) {

				System.out.println("Error when delaying the thread");
			}

			try {
				// >>>
				// **** Send to the coordinator a token request.
				// send your ip address and port number

				//Sends a request for a token to the coordinator
				n_token = new Socket(c_host, c_request_port);

				// Used to indicated when a new request has been received to make it easier to track
				System.out.println("\n-------------------------------------------------------------------------------------------------");
				
				// Message displayed to show that a node has made a request for a token from the coordinator
				System.out.println("Node: token request has been sent to " + c_host + " " + c_return_port);

				//Creates an output stream which will output the port number that the n_token socket is currently using
				//this outpout will be able to be used by an inputstream to get the port number that the token needs to use
				pout = new PrintWriter(n_token.getOutputStream(), true);			
				pout.println(n_port);	
				
				// close the connection that made the request for a token
				n_token.close();

				// >>>
				// **** Wait for the token
				// this is just a synchronization
				// Print suitable messages

				// Message that is displayed while the server is waiting for the token The program will stop at this point while waiting until the token is received
				System.out.println("Node: request sent to the coordinator, Waitng for Token to be received");

				try {
					// >>>
					// Sleep half a second, say
					// This is the critical session

					// Causes a delay for half a second
					Thread.sleep(500);

					// Creates a new server socket that listens on port number that is used by the node
					n_ss = new ServerSocket(n_port);

					// The server accepts the request from the node if it is not currently busy with another request
					n_token = n_ss.accept();

					// Message that the server has accepted the request from the node
					System.out.println("Node: received TOKEN");
					
					// Displays what node the token is currently with
					System.out.println("Node: TOKEN with " + n_host + " " + por);

					// Messages that shows the start of the mutex
					System.out.println(">>>START OF MUTEX<<<");

					// Message that show the start of the critical section
					System.out.println("Node: Entering the critical section");

					// Causes a delay that is equal to the value that was generated by ranSleep to simulate the critical section
					Thread.sleep(ranSleep + 1000);
					
					// Closes the connection to the socket that got the token from the coordinator
					n_token.close();
					
					// Closes the connection to the node
					n_ss.close();

					// >>>
					// **** Return the token
					// this is just establishing a synch connection to the coordinator's ip and return port.
					// Print suitable messages - also considering communication failures
		
		
					// Creates a connection to the coordinator so that the token can be returned
					n_token = new Socket(c_host, c_return_port);

					// Closes the connection that returned the token to the coordinator 
					n_token.close();

					// Message displayed to show that the token has been returned to the coordinator
					System.out.println("Node: token has been returned to " + c_host + " " + c_return_port);

					// Message that is displayed to that the node has exited the critical section
					System.out.println("Node: Exited the critical section");

					// Message that is displayed once the mutex is finished
					System.out.println(">>>END OF MUTEX<<<");
				
				  // Exception that will be displayed if the system crashes during a thread sleep
				} catch (Exception e) {

					System.out.println("C:Node Thread sleeps crashed the system");
					e.printStackTrace();
				}

			}
			// If the coordinator is closed down this message will be displayed once the coordinator is opened the program will continue was normal
			// this will only work if the token is already with the node if the coordinator is closed before the node can receive the request the system will go into a deadlock
			catch (java.io.IOException e) {
				System.out.println(e);
				System.out.println("C:Node Connection was not returned due to The coordinator crashing please restart the coordinator");

			}
		}
	}
}
